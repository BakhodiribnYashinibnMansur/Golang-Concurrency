â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    CUSTOM MUTEX (MONITOR PATTERN) - TASK
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ OBJECTIVE:
-------------
Implement a custom mutex using Go channels (monitor pattern). This implementation
provides thread-safe data access using channels instead of sync.Mutex.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ—ï¸  ARCHITECTURE:
-----------------

The Mutex structure contains:
  â€¢ data: The protected value (generic type T)
  â€¢ read: Channel for read requests (chan chan T)
  â€¢ write: Channel for write requests (chan T)
  â€¢ stop: Channel for cleanup signal (chan struct{})

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ IMPLEMENTATION COMPONENTS:
------------------------------

1. MUTEX STRUCT
   â”œâ”€ Generic type parameter [T any]
   â”œâ”€ data: protected value
   â”œâ”€ read: channel for read operations
   â”œâ”€ write: channel for write operations
   â””â”€ stop: channel for shutdown signal

2. CONSTRUCTORS
   â”œâ”€ NewMutex[T](): Create empty mutex
   â”‚  â”œâ”€ Initialize all channels
   â”‚  â”œâ”€ Start monitor goroutine
   â”‚  â””â”€ Handle requests via select loop
   â”‚
   â””â”€ NewMutexWithValue[T](value): Create mutex with initial value
      â””â”€ Call NewMutex() and set data field directly

3. GET OPERATION
   â”œâ”€ Create response channel
   â”œâ”€ Send response channel to read channel
   â””â”€ Wait for result from response channel

4. SEND OPERATION
   â””â”€ Send new value to write channel

5. CLOSE OPERATION
   â””â”€ Send signal to stop channel

6. TEST CASES
   â”œâ”€ Test 1: Basic Operations
   â”œâ”€ Test 2: Concurrent Access (Stress Test)
   â”œâ”€ Test 3: Resource Clean-up
   â”œâ”€ Test 4: Heavy Load (1000 values)
   â””â”€ Test 5: Concurrent String Access

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”„ HOW IT WORKS:
----------------

Monitor Goroutine:
  â€¢ Runs in infinite loop with select statement
  â€¢ Handles three types of operations:
    1. Read: Receives response channel, sends current data back
    2. Write: Receives new value, updates internal data
    3. Stop: Exits goroutine and cleans up resources

Key Principle:
  â€¢ Only ONE goroutine has direct access to data
  â€¢ All operations are serialized through channels
  â€¢ Race conditions are automatically prevented

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ CORE CONCEPTS:
-----------------

1. MONITOR PATTERN:
   â€¢ Single goroutine has exclusive access to data
   â€¢ All operations are serialized via channels
   â€¢ Race conditions automatically prevented

2. CHANNEL COMMUNICATION:
   â€¢ read: chan chan T - "Send me a response channel" pattern
   â€¢ write: chan T - "Send new value" pattern
   â€¢ stop: chan struct{} - "Signal-only" pattern

3. THREAD SAFETY:
   â€¢ Only one goroutine modifies data at a time
   â€¢ Channels are synchronized by Go runtime
   â€¢ Thread-safe access without explicit locks

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… COMPLETED TASKS:
-------------------

[âœ“] 1. Create generic Mutex struct
[âœ“] 2. Implement NewMutex() constructor
[âœ“] 3. Add NewMutexWithValue() constructor
[âœ“] 4. Implement Get() method - read operation
[âœ“] 5. Implement Send() method - write operation
[âœ“] 6. Implement Close() method - cleanup operation
[âœ“] 7. Create monitor goroutine with select loop
[âœ“] 8. Test 1: Basic operations
[âœ“] 9. Test 2: Concurrent access (10 writers, 10 readers)
[âœ“] 10. Test 3: Resource cleanup
[âœ“] 11. Test 4: Heavy load (1000 values)
[âœ“] 12. Test 5: Concurrent string access (100 writers, 100 readers)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ§ª TEST RESULTS:
----------------

Test 1: Basic Operations
  âœ“ Send and Get operations work correctly
  âœ“ Value updates properly

Test 2: Concurrent Access
  âœ“ 10 writers + 10 readers, 100 iterations each
  âœ“ No deadlocks detected
  âœ“ No race conditions

Test 3: Resource Clean-up
  âœ“ Close() doesn't panic
  âœ“ Goroutine terminates properly

Test 4: Heavy Load
  âœ“ 1000 sequential updates
  âœ“ Each value stored correctly
  âœ“ Good performance

Test 5: Concurrent String Access
  âœ“ 100 writers + 100 readers, 100 ops each
  âœ“ Works with string type
  âœ“ No timeouts

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š PERFORMANCE ANALYSIS:
------------------------

ADVANTAGES:
  âœ“ Simple and understandable code
  âœ“ Safe from race conditions
  âœ“ Generic type support
  âœ“ Protected from deadlocks (with timeouts)
  âœ“ Resource cleanup mechanism

DISADVANTAGES:
  âœ— Slower than sync.Mutex (channel overhead)
  âœ— Channel communication required for each operation
  âœ— Send/Get block after Close() (doesn't panic)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ” IMPORTANT NUANCES:
---------------------

1. RESPONSE CHANNEL PATTERN:
   â€¢ Get() creates a new channel each time
   â€¢ This channel is sent to monitor goroutine
   â€¢ Monitor sends data back through this channel
   â€¢ This pattern enables request-response communication

2. DIRECT DATA ACCESS:
   â€¢ NewMutexWithValue() sets m.data directly
   â€¢ This could be unsafe if mutex is already in use
   â€¢ But safe in constructor (no other goroutines yet)

3. CLOSE SEMANTICS:
   â€¢ Close() stops the monitor goroutine
   â€¢ Send/Get will block after Close() (channels not closed)
   â€¢ Production code should use closed channel pattern

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸš€ FUTURE IMPROVEMENTS:
-----------------------

[ ] 1. TryGet() - non-blocking read
[ ] 2. TrySend() - non-blocking write
[ ] 3. GetWithTimeout() - read with timeout
[ ] 4. SendWithTimeout() - write with timeout
[ ] 5. Panic after Close() is called
[ ] 6. Closed() bool method - check mutex state
[ ] 7. Add benchmark tests
[ ] 8. Performance comparison with sync.Mutex
[ ] 9. Add context support
[ ] 10. Multiple readers, single writer pattern

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“š CONCEPTS LEARNED:
--------------------

1. Monitor Pattern
   â€¢ Single goroutine manages shared state
   â€¢ Communication via channels

2. Channel Patterns
   â€¢ chan chan T - response channel pattern
   â€¢ chan struct{} - signal-only channel

3. Generic Programming
   â€¢ Type parameters [T any]
   â€¢ Type-safe data structures

4. Concurrency Safety
   â€¢ Channel-based synchronization
   â€¢ Select statement
   â€¢ Goroutine lifecycle management

5. Testing Strategies
   â€¢ Concurrent stress testing
   â€¢ Timeout-based deadlock detection
   â€¢ Race condition testing

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ’¡ WHEN TO USE:
---------------

CUSTOM MUTEX (Channel-based):
  âœ“ For learning and understanding
  âœ“ When complex state machine is needed
  âœ“ When request-response pattern is required
  âœ“ When serialized access is needed

SYNC.MUTEX:
  âœ“ In production code
  âœ“ When performance is critical
  âœ“ When simple lock/unlock is sufficient
  âœ“ When standard library is adequate

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ CONCLUSION:
--------------

This custom mutex implementation demonstrates how Go's concurrency primitives
(channels and goroutines) can be used for synchronization. While sync.Mutex is
better for production code, this implementation is excellent for understanding
the monitor pattern and channel-based communication.

The monitor pattern is a classic concurrency pattern based on the idea of
managing shared state through a single goroutine and serializing all access
through channels.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ NOTE:
--------

This implementation was created for educational purposes. For production code,
use sync.Mutex or sync.RWMutex because they:
  â€¢ Run faster
  â€¢ Use less memory
  â€¢ Are optimized by Go runtime
  â€¢ Have deadlock detection mechanisms

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”‘ KEY TAKEAWAYS:
-----------------

1. Channels can be used for synchronization, not just communication
2. Monitor pattern provides thread-safety without explicit locks
3. Generic types enable reusable, type-safe concurrent data structures
4. Select statement is powerful for managing multiple channel operations
5. Understanding custom implementations helps appreciate standard library
6. Trade-offs exist between simplicity, performance, and safety
7. Educational implementations teach concepts that apply broadly

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
